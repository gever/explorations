<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Applesofty BASIC Transpiler</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            margin: 0; padding: 20px;
            background-color: #111;
            color: #33ff33;
            font-family: 'VT323', monospace;
            height: 100vh;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #monitor {
            width: 1320px;
            height: 1000px;
            background-color: #000;
            border: 20px solid #333;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.9);
            padding: 20px;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            max-width: 95vw;
            max-height: 95vh;
        }

        #monitor::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
            background-size: 100% 4px;
            z-index: 20;
            pointer-events: none;
        }

        canvas {
            background-color: #000;
            image-rendering: pixelated; 
            width: 100%;
            height: 100%;
            z-index: 1;
            cursor: text;
        }

        #help-overlay {
            position: absolute;
            top: 40px; left: 40px; right: 40px; bottom: 40px;
            z-index: 50;
            display: none;
            flex-direction: column;
            box-shadow: 0 20px 50px rgba(0,0,0,0.9);
            border: 1px solid #444;
        }

        .help-header {
            display: flex; justify-content: space-between; align-items: center;
            background: #222; color: #ccc; padding: 10px 20px;
            font-family: sans-serif; font-size: 14px;
            border-bottom: 2px solid #000;
        }
        
        #help-search {
            background: #444; border: 1px solid #666; color: white;
            padding: 5px 10px; font-family: sans-serif; width: 200px;
        }

        .help-close {
            background: #c00; color: white; border: none;
            padding: 5px 15px; cursor: pointer; font-weight: bold;
        }

        .printer-paper {
            flex-grow: 1;
            background-color: #f4f4f0;
            background-image: repeating-linear-gradient(to bottom, #f4f4f0, #f4f4f0 40px, #e8eadd 40px, #e8eadd 80px);
            color: #333;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            line-height: 1.5;
            overflow-y: auto;
            padding: 20px 40px;
            border-left: 12px dotted #bbb;
            border-right: 12px dotted #bbb;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.1);
        }

        .help-section { margin-bottom: 40px; border-top: 2px solid #000; padding-top: 20px; }
        .help-title { font-size: 1.8em; font-weight: 900; margin-bottom: 15px; text-transform: uppercase; letter-spacing: 2px; }
        .help-entry { margin-bottom: 20px; break-inside: avoid; }
        .help-cmd { font-weight: bold; font-size: 1.2em; color: #000; background: rgba(0,0,0,0.05); display: inline-block; padding: 0 5px; }
        .help-desc { margin: 5px 0 5px 20px; }
        .help-ex { margin-left: 20px; color: #004488; font-family: monospace; font-weight: bold; }
        .help-ex::before { content: "Ex: "; color: #666; font-weight: normal; }

        .index-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 15px; margin-bottom: 30px; }
        .index-btn { 
            background: #fff; border: 2px solid #333; padding: 10px; 
            cursor: pointer; text-align: center; font-weight: bold; font-family: 'Courier New', monospace;
            box-shadow: 3px 3px 0px rgba(0,0,0,0.2); transition: transform 0.1s;
        }
        .index-btn:active { transform: translate(2px, 2px); box-shadow: 1px 1px 0px rgba(0,0,0,0.2); }

        #break-btn {
            position: absolute; top: 30px; right: 40px;
            background: #cc0000; color: #fff; border: 2px solid #ff0000;
            font-family: 'VT323', monospace; font-size: 24px;
            padding: 5px 15px; cursor: pointer;
            display: none; z-index: 100;
            text-transform: uppercase; font-weight: bold;
        }
        
        #input-trap { position: absolute; opacity: 0; top: -1000px; }
    </style>
</head>
<body>

    <div id="monitor">
        <button id="break-btn">STOP (ESC)</button>
        <canvas id="main-canvas" width="640" height="480"></canvas>
        
        <div id="help-overlay">
            <div class="help-header">
                <span>APPLESOFT REFERENCE MANUAL</span>
                <input type="text" id="help-search" placeholder="FILTER COMMANDS..." autocomplete="off">
                <button class="help-close" onclick="document.getElementById('help-overlay').style.display='none'">CLOSE</button>
            </div>
            <div class="printer-paper" id="help-content"></div>
        </div>

        <input type="text" id="input-trap" autocomplete="off" autofocus>
    </div>

    <script>
        /**
         * APPLESOFT BASIC INTERPRETER v18.2 (Natural Rendering)
         */

        const CONFIG = {
            // These will be calculated dynamically in SCREEN.init()
            cols: 40, rows: 24, 
            charW: 0, charH: 0, 

            width: 640, height: 480,
            font: '26px VT323',
            // Offsets removed for natural rendering
            fontOffsetY: 0, fontOffsetX: 0,
            
            color: '#33ff33', bgColor: '#000000',
            
            // Graphics still map to 640x480
            scaleX: 640 / 280, 
            scaleY: 480 / 192
        };

        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
        const inputTrap = document.getElementById('input-trap');
        const breakBtn = document.getElementById('break-btn');
        const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;

        // --- SCREEN MEMORY ---
        const SCREEN = {
            cx: 0, cy: 0,
            isCursorDrawn: false,

            init: () => {
                ctx.font = CONFIG.font;
                ctx.textBaseline = 'top';
                
                // --- CHANGED: Calculate Natural Font Metrics ---
                const metrics = ctx.measureText("M"); // Measure standard char width
                CONFIG.charW = Math.ceil(metrics.width);
                CONFIG.charH = 26; // Match font size for natural line height
                
                // Recalculate Columns/Rows based on natural size
                CONFIG.cols = Math.floor(CONFIG.width / CONFIG.charW);
                CONFIG.rows = Math.floor(CONFIG.height / CONFIG.charH);

                ctx.fillStyle = CONFIG.bgColor;
                ctx.fillRect(0, 0, CONFIG.width, CONFIG.height);
                SCREEN.drawCursor();
            },

            clear: () => {
                SCREEN.removeCursor();
                ctx.fillStyle = CONFIG.bgColor;
                ctx.fillRect(0, 0, CONFIG.width, CONFIG.height);
                SCREEN.cx = 0; SCREEN.cy = 0;
                SCREEN.drawCursor();
            },

            scroll: () => {
                SCREEN.removeCursor();
                ctx.drawImage(canvas, 
                    0, CONFIG.charH, CONFIG.width, CONFIG.height - CONFIG.charH, 
                    0, 0, CONFIG.width, CONFIG.height - CONFIG.charH
                );
                ctx.fillStyle = CONFIG.bgColor;
                ctx.fillRect(0, CONFIG.height - CONFIG.charH, CONFIG.width, CONFIG.charH);
                SCREEN.drawCursor();
            },

            newline: () => {
                SCREEN.removeCursor();
                SCREEN.cx = 0; SCREEN.cy++;
                if (SCREEN.cy >= CONFIG.rows) { SCREEN.cy = CONFIG.rows - 1; SCREEN.scroll(); }
                else SCREEN.drawCursor();
            },

            put: (str) => {
                SCREEN.removeCursor();
                ctx.font = CONFIG.font;
                
                for (let char of str) {
                    if (char === '\n') {
                        SCREEN.cx = 0; SCREEN.cy++;
                        if (SCREEN.cy >= CONFIG.rows) {
                            SCREEN.cy = CONFIG.rows - 1;
                            ctx.drawImage(canvas, 0, CONFIG.charH, CONFIG.width, CONFIG.height - CONFIG.charH, 0, 0, CONFIG.width, CONFIG.height - CONFIG.charH);
                            ctx.fillStyle = CONFIG.bgColor;
                            ctx.fillRect(0, CONFIG.height - CONFIG.charH, CONFIG.width, CONFIG.charH);
                        }
                    } else {
                        // Clear cell background
                        ctx.fillStyle = CONFIG.bgColor;
                        ctx.fillRect(SCREEN.cx * CONFIG.charW, SCREEN.cy * CONFIG.charH, CONFIG.charW, CONFIG.charH);
                        // Draw char
                        ctx.fillStyle = CONFIG.color;
                        ctx.fillText(char, (SCREEN.cx * CONFIG.charW) + CONFIG.fontOffsetX, (SCREEN.cy * CONFIG.charH) + CONFIG.fontOffsetY);
                        
                        SCREEN.cx++;
                        if (SCREEN.cx >= CONFIG.cols) {
                            SCREEN.cx = 0; SCREEN.cy++;
                            if (SCREEN.cy >= CONFIG.rows) {
                                SCREEN.cy = CONFIG.rows - 1;
                                ctx.drawImage(canvas, 0, CONFIG.charH, CONFIG.width, CONFIG.height - CONFIG.charH, 0, 0, CONFIG.width, CONFIG.height - CONFIG.charH);
                                ctx.fillStyle = CONFIG.bgColor;
                                ctx.fillRect(0, CONFIG.height - CONFIG.charH, CONFIG.width, CONFIG.charH);
                            }
                        }
                    }
                }
                SCREEN.drawCursor();
            },

            drawCursor: () => {
                if (!IO.cursorVisible || SCREEN.isCursorDrawn) return;
                const x = SCREEN.cx * CONFIG.charW;
                const y = SCREEN.cy * CONFIG.charH;
                ctx.save();
                ctx.globalCompositeOperation = 'difference';
                ctx.fillStyle = CONFIG.color; 
                ctx.fillRect(x, y, CONFIG.charW, CONFIG.charH);
                ctx.restore();
                SCREEN.isCursorDrawn = true;
            },

            removeCursor: () => {
                if (!SCREEN.isCursorDrawn) return;
                const x = SCREEN.cx * CONFIG.charW;
                const y = SCREEN.cy * CONFIG.charH;
                ctx.save();
                ctx.globalCompositeOperation = 'difference';
                ctx.fillStyle = CONFIG.color;
                ctx.fillRect(x, y, CONFIG.charW, CONFIG.charH);
                ctx.restore();
                SCREEN.isCursorDrawn = false;
            }
        };

        // --- GRAPHICS ---
        const GRAPHICS = {
            lastX:0, lastY:0, colorIdx:3, 
            colors: ['#000000', '#14F53C', '#A040A0', '#FFFFFF', '#000000', '#FF6000', '#3040FF', '#FFFFFF'],
            mapX: (x) => Math.floor(x * CONFIG.scaleX),
            mapY: (y) => Math.floor(y * CONFIG.scaleY),
            setMode: (m) => { if(m>0) SCREEN.clear(); }, 
            clear: () => SCREEN.clear(),
            setColor: (c) => { GRAPHICS.colorIdx = Math.floor(c)%8; console.log("colorIdx = ", GRAPHICS.colorIdx); },
            plot: (x,y) => {
                SCREEN.removeCursor();
                ctx.globalCompositeOperation = 'source-over'; // <--- ADD THIS
                ctx.fillStyle=GRAPHICS.colors[GRAPHICS.colorIdx]; 
                const cx = GRAPHICS.mapX(x), cy = GRAPHICS.mapY(y);
                ctx.fillRect(cx, cy, Math.ceil(CONFIG.scaleX), Math.ceil(CONFIG.scaleY)); 
                GRAPHICS.lastX=cx; GRAPHICS.lastY=cy; 
            },
            lineTo: (x,y) => {
                SCREEN.removeCursor();
                ctx.globalCompositeOperation = 'source-over'; // <--- ADD THIS
                ctx.strokeStyle=GRAPHICS.colors[GRAPHICS.colorIdx]; ctx.lineWidth=2; ctx.beginPath();
                const tx = GRAPHICS.mapX(x), ty = GRAPHICS.mapY(y);
                ctx.moveTo(GRAPHICS.lastX+(CONFIG.scaleX/2), GRAPHICS.lastY+(CONFIG.scaleY/2));
                ctx.lineTo(tx+(CONFIG.scaleX/2), ty+(CONFIG.scaleY/2)); 
                ctx.stroke(); 
                GRAPHICS.lastX=tx; GRAPHICS.lastY=ty;
            },
        };

        // --- MEMORY & STATE ---
        const SYS = {
            vars: {}, arrays: {}, program: [], compiled: [],
            pc: 0, labels: {}, stack: [], forStack: {},
            running: false, break: false, inputCallback: null,
            getArray: (n, i) => { if (!SYS.arrays[n]) throw `UNDEFINED ARRAY ${n}`; return SYS.arrays[n][i]; },
            setArray: (n, i, v) => { if (!SYS.arrays[n]) throw `UNDEFINED ARRAY ${n}`; SYS.arrays[n][i] = v; }
        };

        // --- DEMOS ---
        const DEMOS = {
            "DEMO/ANIM.BAS": [
                {line: 10, src: 'HOME'}, {line: 20, src: 'PRINT "ANIMATION DEMO - USE SETPOS"'},
                {line: 30, src: 'FOR I = 1 TO 22'}, {line: 40, src: 'SETPOS I, I : PRINT "O"'},
                {line: 50, src: 'SETPOS 39-I, I : PRINT "X"'}, {line: 60, src: 'NEXT I'},
                {line: 70, src: 'VTAB 23 : PRINT "DONE"'}, {line: 80, src: 'END'}
            ],
            "DEMO/PERFORMANCE.BAS": [
                {line: 10, src: 'HOME: PRINT "BENCHMARKING..."'}, {line: 20, src: 'SUM = 0'},
                {line: 30, src: 'FOR I = 1 TO 10000 : SUM = SUM + 1 : NEXT I'},
                {line: 40, src: 'PRINT "SUM: "; SUM'}, {line: 50, src: 'END'}
            ],
            "DEMO/GRAPHICS.BAS": [
                {line: 10, src: 'HGR2 : HCOLOR=3'}, {line: 20, src: 'FOR I=0 TO 191 STEP 5'},
                {line: 30, src: 'HPLOT 0,0 TO 279,I'}, {line: 40, src: 'NEXT I'},
                {line: 50, src: 'INPUT ""; X$ : TEXT : END'}
            ],
            "DEMO/MIXED.BAS": [
                 {line:10, src:'HOME : HCOLOR=3'},
                 {line:20, src:'FOR I=0 TO 190 STEP 10'},
                 {line:30, src:'HPLOT 0,I TO 279,190-I'},
                 {line:40, src:'NEXT I'},
                 {line:50, src:'VTAB 12 : HTAB 12 : PRINT "MIXED TEXT & GRAPHICS"'},
                 {line:60, src:'HPLOT 0,0 TO 279,191'}
            ]
        };

        // --- HELP DATA ---
        const HELP_DATA = {
            "SYSTEM & FILES": [
                { c: "RUN", d: "Executes the program currently in memory. Clears variables.", e: "RUN" },
                { c: "LIST", d: "Displays the source code of the current program.", e: "LIST" },
                { c: "NEW", d: "Clears the current program from memory and resets variables.", e: "NEW" },
                { c: "SAVE", d: "Saves current program to browser local storage.", e: "SAVE \"MYGAME\"" },
                { c: "LOAD", d: "Loads a program from local storage or demo library.", e: "LOAD \"DEMO/GRAPHICS.BAS\"" },
                { c: "DIR", d: "Lists all saved files and available demos.", e: "DIR" },
                { c: "DOWNLOAD", d: "Downloads the program as a .BAS text file to your computer.", e: "DOWNLOAD \"GAME\"" },
                { c: "HELP", d: "Opens this reference manual.", e: "HELP" },
                { c: "REM", d: "Remark/Comment. Line is ignored by interpreter.", e: "10 REM SETUP VARIABLES" }
            ],
            "SCREEN & GRAPHICS": [
                { c: "HOME", d: "Clears the text screen and moves cursor to top-left.", e: "10 HOME" },
                { c: "TEXT", d: "Legacy command (Clears screen in Mixed Mode).", e: "100 TEXT" },
                { c: "HGR", d: "Legacy command (Clears screen in Mixed Mode).", e: "10 HGR" },
                { c: "HGR2", d: "Legacy command (Clears screen in Mixed Mode).", e: "10 HGR2" },
                { c: "HCOLOR", d: "Sets drawing color (0-7) for HPLOT.", e: "20 HCOLOR = 3" },
                { c: "HPLOT", d: "Plots a point or draws lines on the graphics screen.", e: "30 HPLOT 0,0 TO 100,100" },
                { c: "HTAB", d: "Moves cursor to horizontal column X (1-40).", e: "10 HTAB 20" },
                { c: "VTAB", d: "Moves cursor to vertical row Y (1-24).", e: "20 VTAB 12" },
                { c: "SETPOS", d: "Moves cursor to X, Y coordinates (Custom).", e: "30 SETPOS 15, 10" }
            ],
            "I/O & CONTROL": [
                { c: "PRINT", d: "Outputs text or variables. Use ; to suppress newline.", e: "10 PRINT \"SCORE: \"; S" },
                { c: "INPUT", d: "Pauses to get value from user.", e: "20 INPUT \"NAME? \"; N$" },
                { c: "GOTO", d: "Unconditional jump to line number.", e: "50 GOTO 10" },
                { c: "GOSUB", d: "Jump to subroutine. Returns on RETURN.", e: "10 GOSUB 1000" },
                { c: "RETURN", d: "Return from subroutine.", e: "1000 RETURN" },
                { c: "IF...THEN", d: "Conditional execution.", e: "10 IF A > 10 THEN GOTO 50" },
                { c: "FOR...NEXT", d: "Loop structure.", e: "10 FOR I=1 TO 10 STEP 2 ... 50 NEXT I" },
                { c: "END", d: "Stops program execution.", e: "99 END" },
                { c: "DIM", d: "Defines array size.", e: "10 DIM A(100)" },
                { c: "LET", d: "Assigns value to variable (optional keyword).", e: "10 LET A = 5" }
            ],
            "MATH FUNCTIONS": [
                { c: "SIN(X)", d: "Sine of X (radians).", e: "Y = SIN(3.14)" },
                { c: "COS(X)", d: "Cosine of X (radians).", e: "Y = COS(0)" },
                { c: "TAN(X)", d: "Tangent of X.", e: "Y = TAN(1)" },
                { c: "ATN(X)", d: "Arctangent of X.", e: "Y = ATN(1)" },
                { c: "SQR(X)", d: "Square root.", e: "Y = SQR(16)" },
                { c: "ABS(X)", d: "Absolute value.", e: "Y = ABS(-5)" },
                { c: "INT(X)", d: "Integer part (Floor).", e: "Y = INT(3.9)" },
                { c: "EXP(X)", d: "e raised to power X.", e: "Y = EXP(1)" },
                { c: "LOG(X)", d: "Natural logarithm.", e: "Y = LOG(10)" },
                { c: "RND(1)", d: "Random number 0.0 to 1.0.", e: "R = RND(1)" },
                { c: "RAND(X)", d: "Random number 0 to X.", e: "R = RAND(100)" }
            ],
            "STRING FUNCTIONS": [
                { c: "LEN(S$)", d: "Length of string.", e: "L = LEN(\"ABC\")" },
                { c: "LEFT$(S$,N)", d: "First N chars.", e: "A$ = LEFT$(\"HELLO\", 2)" },
                { c: "RIGHT$(S$,N)", d: "Last N chars.", e: "A$ = RIGHT$(\"WORLD\", 3)" },
                { c: "MID$(S$,I,N)", d: "N chars starting at I.", e: "A$ = MID$(\"ABC\", 2, 1)" },
                { c: "STR$(N)", d: "Convert number to string.", e: "A$ = STR$(123)" },
                { c: "VAL(S$)", d: "Convert string to number.", e: "N = VAL(\"12.5\")" }
            ]
        };

        // --- FILE SYSTEM ---
        const FS = {
            PREFIX: 'APPLESOFT_PROG_',
            save: (fn) => { try { localStorage.setItem(FS.PREFIX+fn.toUpperCase(), JSON.stringify(SYS.program)); IO.print("SAVED "+fn); } catch(e){ IO.print("?DISK FULL"); } },
            load: (fn) => {
                const f = fn.toUpperCase();
                if (DEMOS[f]) { SYS.program = JSON.parse(JSON.stringify(DEMOS[f])); SYS.vars={}; SYS.arrays={}; SCREEN.clear(); IO.print("LOADED DEMO"); return; }
                const d = localStorage.getItem(FS.PREFIX + f);
                if (d) { SYS.program = JSON.parse(d); SYS.vars={}; SYS.arrays={}; SCREEN.clear(); IO.print("LOADED"); } else IO.print("?FILE NOT FOUND");
            },
            dir: () => {
                IO.print("CATALOG");
                IO.print(" [DEMOS]"); for(let k in DEMOS) IO.print("  " + k);
                IO.print(" [USER]"); for (let i=0; i<localStorage.length; i++) { const k=localStorage.key(i); if(k.startsWith(FS.PREFIX)) IO.print("  " + k.replace(FS.PREFIX,'')); }
            },
            download: (fn) => {
                SYS.program.sort((a,b)=>a.line-b.line);
                const t = SYS.program.map(l=>`${l.line} ${l.src}`).join("\n");
                const b = new Blob([t],{type:'text/plain'}); const u = URL.createObjectURL(b);
                const a = document.createElement('a'); a.href=u; a.download=(fn||"PROG")+".BAS";
                document.body.appendChild(a); a.click(); document.body.removeChild(a);
            }
        };

        // --- COMPILER ---
        const LIB = {
            'SIN': 'Math.sin', 'COS': 'Math.cos', 'TAN': 'Math.tan', 'ATN': 'Math.atan', 'EXP': 'Math.exp', 'LOG': 'Math.log', 'SQR': 'Math.sqrt', 'ABS': 'Math.abs',
            'INT': 'Math.floor', 'RND': '(x)=>Math.random()', 'RAND': '(x)=>Math.random()*x',
            'LEN': '(s)=>(s+"").length', 'LEFT$': '(s,n)=>(s+"").substr(0,n)', 'RIGHT$': '(s,n)=>(s+"").substr((s+"").length-n)', 'MID$': '(s,st,ln)=>(s+"").substr(st-1,ln)',
            'STR$': '(n)=>n.toString()', 'VAL': '(s)=>parseFloat(s)'
        };
        const Tokenizer = { regex: /([0-9]*\.?[0-9]+)|(".*?")|([a-zA-Z][a-zA-Z0-9_]*\$?)|(<=|>=|<>|<|>|=)|([\+\-\*\/])|(\()|(\))|(:)|(,)|(;)/g, tokenize: (str)=>{const t=[];let m;while((m=Tokenizer.regex.exec(str))!==null)t.push(m[0]);return t;} };
        const Compiler = {
            genExpression: (tokens, ctx) => {
                const peek=()=>tokens[ctx.idx], next=()=>tokens[ctx.idx++];
                const parseExp=()=>{ let l=parseTerm(); while(ctx.idx<tokens.length&&(peek()==='+'||peek()==='-')) l=`(${l} ${next()} ${parseTerm()})`; if(ctx.idx<tokens.length&&['=','<','>','<=','>=','<>'].includes(peek())){let op=next(),jop=op==='='?'===':op==='<>'?'!==':op;l=`(${l} ${jop} ${parseExp()}?1:0)`;} return l; };
                const parseTerm=()=>{ let l=parseFactor(); while(ctx.idx<tokens.length&&(peek()==='*'||peek()==='/')) l=`(${l} ${next()} ${parseFactor()})`; return l; };
                const parseFactor=()=>{
                    const t=next(); 
                    if(!t) return "0"; 
                    if(!isNaN(t)||t.startsWith('"')) return t; 
                    if(t==='('){const e=parseExp();next();return `(${e})`;}
                    
                    if(/^[a-zA-Z]/.test(t)){ 
                        // Normalize token for Keyword/Function checks
                        const tu = t.toUpperCase();
                        
                        // Handle INKEY$
                        if(tu === 'INKEY$') {
                            ctx.setAsync(); 
                            next(); // consume '('
                            const mode = parseExp(); 
                            next(); // consume ')'
                            return `(await IO.inkey(${mode}))`;
                        }

                        // Handle Math Functions (SIN, LEN, etc)
                        if(LIB[tu]){
                            next();const a=[];
                            if(peek()!==')')do{a.push(parseExp());if(peek()===',')next();else break;}while(true);
                            next();return `${LIB[tu]}(${a.join(',')})`;
                        } 
                        
                        // Handle Array Access (Use raw 't' to preserve case)
                        if(peek()==='('){next();const i=parseExp();next();return `SYS.getArray('${t}',${i})`;} 
                        
                        // Handle Variables (Use raw 't' to preserve case)
                        return `(SYS.vars['${t}']!==undefined?SYS.vars['${t}']:0)`; 
                    } 
                    return "0";
                };
                return parseExp();
            },
            compile: (lineObj) => {
                // CHANGE: Do NOT uppercase the source string here.
                const tokens=Tokenizer.tokenize(lineObj.src); 
                
                let async = false;
                const ctx={idx:0, jsLoops:[], setAsync: () => async = true};
                
                // Helper to check next token case-insensitively without consuming it
                const peekUpper=()=>(tokens[ctx.idx]||"").toUpperCase();

                const peek=()=>tokens[ctx.idx], next=()=>tokens[ctx.idx++], remain=()=>tokens.slice(ctx.idx);
                let body = "";

                while(ctx.idx < tokens.length) {
                    const cmdRaw = next();
                    if (cmdRaw === ':') continue; if (cmdRaw.toUpperCase() === 'REM') break;
                    
                    // Normalize command to uppercase for switching
                    const cmd = cmdRaw.toUpperCase(); 
                    let chunk = "";

                    if(cmd==='PRINT'){ 
                        if(!peek()) chunk="IO.print('');"; 
                        else { 
                            // Check keywords case-insensitively
                            const p=[]; while(ctx.idx<tokens.length){ if(peek()===';'||peek()===','){next();continue;} if([':','THEN','ELSE'].includes(peekUpper())) break; p.push(Compiler.genExpression(tokens,ctx)); if(peek()===';')next(); } 
                            chunk=`IO.print(${p.length?p.join(' + "" + '):'""'});`; 
                        } 
                        chunk+=` if(SYS.break){SYS.running=false;return;}`; 
                    }
                    else if(cmd==='GOTO'){ const l=Number(next()); chunk=`if(SYS.labels[${l}]!==undefined)SYS.pc=SYS.labels[${l}]-1;`; }
                    else if(cmd==='IF'){ 
                        const cond=Compiler.genExpression(tokens,ctx); 
                        // Case-insensitive 'THEN'
                        if(next().toUpperCase()!=='THEN') throw "SYNTAX"; let tb; 
                        if(!isNaN(peek())) tb=`if(SYS.labels[${Number(next())}]!==undefined)SYS.pc=SYS.labels[${Number(next())}]-1;`; 
                        else { const sid="SUB_"+Math.random().toString(36).substr(2,9); SYS[sid]=Compiler.compile({line:lineObj.line,src:remain().join(" ")}); tb=`return SYS['${sid}'](SYS,IO,GRAPHICS,FS);`; } 
                        chunk=`if(${cond}){${tb}}`; ctx.idx = tokens.length; 
                    }
                    else if(cmd==='FOR'){ 
                        const v=next(); // Variable name (keep case)
                        next(); // '='
                        const s=Compiler.genExpression(tokens,ctx); 
                        next(); // 'TO' (ignored, but we blindly consume it)
                        const e=Compiler.genExpression(tokens,ctx); 
                        let st="1"; if(peekUpper()==='STEP'){next();st=Compiler.genExpression(tokens,ctx);} 
                        
                        let isSingle = false;
                        // Case-insensitive lookahead for NEXT
                        for(let k=ctx.idx; k<tokens.length; k++){ if(tokens[k].toUpperCase()==='NEXT' && tokens[k+1]===v) { isSingle=true; break; } }

                        if(isSingle) {
                            chunk = `{ const _st=${st}; for(SYS.vars['${v}']=${s}; (_st>=0?SYS.vars['${v}']<=${e}:SYS.vars['${v}']>=${e}); SYS.vars['${v}']+=_st) {`;
                            ctx.jsLoops.push(v);
                        } else {
                            chunk=`SYS.vars['${v}']=${s};SYS.forStack['${v}']={target:${e},step:${st},pc:SYS.pc};`; 
                        }
                    }
                    else if(cmd==='NEXT'){ 
                        const v=next(); // Variable name (keep case)
                        if(ctx.jsLoops.length > 0 && ctx.jsLoops[ctx.jsLoops.length-1] === v) {
                            chunk = `}}`; ctx.jsLoops.pop();
                        } else {
                            chunk=`var l=SYS.forStack['${v}'];if(l){SYS.vars['${v}']+=l.step;if((l.step>=0&&SYS.vars['${v}']<=l.target)||(l.step<0&&SYS.vars['${v}']>=l.target))SYS.pc=l.pc;else delete SYS.forStack['${v}'];}`; 
                        }
                    }
                    else if(cmd==='DIM'){ const v=next(); next(); const sz=Compiler.genExpression(tokens,ctx); next(); chunk=`SYS.arrays['${v}']=new Array(${sz}+1).fill(0);`; }
                    else if(cmd==='INPUT'){ async=true; let p="?"; if(peek().startsWith('"')){p=next().replace(/"/g,'');if(peek()===';')next();} const v=next(), str=v.endsWith('$'); chunk=`IO.print("${p}",false);var val=await IO.input();SYS.vars['${v}']=${str?'val':'parseFloat(val)'};`; }

                    else if(cmd==='HGR'||cmd==='HGR2'||cmd==='TEXT') chunk=`GRAPHICS.setMode(1);`;
                    else if(cmd==='HCOLOR'){ 
                        if(peek() === '=') next(); 
                        chunk=`GRAPHICS.setColor(${Compiler.genExpression(tokens,ctx)});`; 
                    }
                    else if(cmd==='HPLOT'){ 
                        let sc="", sl=false; 
                        if(peekUpper()==='TO'){ next(); sl=true; } 
                        else {
                            const x=Compiler.genExpression(tokens,ctx); 
                            if(peek()===',') next(); 
                            sc=`GRAPHICS.plot(${x},${Compiler.genExpression(tokens,ctx)});`;
                        } 
                        let lc=""; 
                        while(peekUpper()==='TO'){
                            next(); const x=Compiler.genExpression(tokens,ctx); 
                            if(peek()===',') next(); 
                            lc+=`GRAPHICS.lineTo(${x},${Compiler.genExpression(tokens,ctx)});`;
                        } 
                        chunk=(sl?"":sc)+lc; 
                    }
                    
                    else if(cmd==='LET'||(cmd&&peek()==='=')||(cmd&&peek()==='(')){ 
                        let v=cmdRaw; // Use raw for variable name
                        if(cmd==='LET') v=next(); 
                        if(peek()==='('){
                            next(); const i=Compiler.genExpression(tokens,ctx); next(); next();
                            chunk=`SYS.setArray('${v}',${i},${Compiler.genExpression(tokens,ctx)});`;
                        } else {
                            next(); 
                            chunk=`SYS.vars['${v}']=${Compiler.genExpression(tokens,ctx)};`;
                        } 
                    }

                    else if(cmd==='HTAB') chunk=`IO.htab(${Compiler.genExpression(tokens,ctx)});`;
                    else if(cmd==='VTAB') chunk=`IO.vtab(${Compiler.genExpression(tokens,ctx)});`;
                    else if(cmd==='SETPOS') { const x=Compiler.genExpression(tokens,ctx); next(); const y=Compiler.genExpression(tokens,ctx); chunk=`IO.setPos(${x},${y});`; }
                    else if(cmd==='HOME') chunk="IO.home();";
                    else if(cmd==='END') chunk="SYS.running=false;";
                    else if(cmd==='DELAY') { async=true; chunk=`await new Promise(r=>setTimeout(r,${Compiler.genExpression(tokens,ctx)}));`; }
                    else if(cmd==='SAVE') chunk=`FS.save(${Compiler.genExpression(tokens,ctx)});`;
                    else if(cmd==='LOAD') chunk=`FS.load(${Compiler.genExpression(tokens,ctx)});`;
                    else if(cmd==='DIR'||cmd==='CATALOG') chunk=`FS.dir();`;
                    else if(cmd==='DOWNLOAD') chunk=`FS.download(${Compiler.genExpression(tokens,ctx)});`;
                    else if(cmd==='HELP') chunk=`IO.help();`;
                    else chunk=`IO.print("?SYNTAX ERROR");`;

                    body += chunk + "\n";
                }

                try { return new (async?AsyncFunction:Function)("SYS","IO","GRAPHICS","FS",body); } catch(e){ return ()=>IO.print(`?COMPILE ERROR ${lineObj.line}`); }
            }
        };

        // --- I/O & HELP ---
        const IO = {
            cursorVisible: true,
            buffer: [], // Keyboard buffer
            waiter: null, // Callback for blocking wait
            
            // --- NEW: Key buffering logic ---
            bufferKey: (key) => {
                // Map Enter to Carriage Return, ignore special keys like Shift/Ctrl
                if(key.length === 1 || key === 'Enter') {
                    const k = key === 'Enter' ? '\r' : key;
                    if(IO.waiter) {
                        // If waiting (INKEY$ 1), resolve immediately
                        const w = IO.waiter; IO.waiter = null; w(k);
                    } else {
                        // Otherwise push to buffer (limit 16 chars)
                        IO.buffer.push(k);
                        if(IO.buffer.length > 16) IO.buffer.shift();
                    }
                }
            },
            inkey: async (mode) => {
                // Mode 0: Non-blocking (poll)
                if (Math.floor(mode) === 0) return IO.buffer.shift() || "";
                
                // Mode 1: Blocking (wait)
                if (IO.buffer.length > 0) return IO.buffer.shift();
                return new Promise(r => IO.waiter = r);
            },
            // --------------------------------

            help: () => {
                const ov = document.getElementById('help-overlay'), ct = document.getElementById('help-content'), search = document.getElementById('help-search');
                ov.style.display = 'flex'; search.focus();
                
                const render = (filter = "") => {
                    let html = "<div class='help-title' style='text-align:center'>QUICK INDEX</div><div class='index-grid'>";
                    const keys = Object.keys(HELP_DATA);
                    keys.forEach(cat => { html += `<button class='index-btn' onclick="document.getElementById('sec-${cat}').scrollIntoView({behavior:'smooth'})">${cat}</button>`; });
                    html += "</div><hr/><br/>";
                    keys.forEach(cat => {
                        html += `<div id='sec-${cat}' class='help-section'><div class='help-title'>${cat}</div>`;
                        HELP_DATA[cat].forEach(item => {
                            if(!filter || item.c.includes(filter.toUpperCase()) || item.d.toUpperCase().includes(filter.toUpperCase())) {
                                html += `<div class='help-entry'><div class='help-cmd'>${item.c}</div><div class='help-desc'>${item.d}</div><div class='help-ex'>${item.e}</div></div>`;
                            }
                        });
                        html += "</div>";
                    });
                    ct.innerHTML = html;
                };
                render(); search.onkeyup = (e) => render(e.target.value);
            },
            print: (txt, newline=true) => { SCREEN.put(txt.toString()); if(newline) SCREEN.newline(); },
            input: () => { 
                IO.cursorVisible = true; SCREEN.drawCursor(); 
                return new Promise(r => { SYS.inputCallback = r; inputTrap.value=""; inputTrap.focus(); }); 
            },
            home: () => SCREEN.clear(),
            htab: (x) => { SCREEN.removeCursor(); SCREEN.cx = Math.max(0, Math.min(CONFIG.cols-1, x-1)); SCREEN.drawCursor(); },
            vtab: (y) => { SCREEN.removeCursor(); SCREEN.cy = Math.max(0, Math.min(CONFIG.rows-1, y-1)); SCREEN.drawCursor(); },
            setPos: (x, y) => { SCREEN.removeCursor(); SCREEN.cx = Math.max(0, Math.min(CONFIG.cols-1, x-1)); SCREEN.cy = Math.max(0, Math.min(CONFIG.rows-1, y-1)); SCREEN.drawCursor(); },
            handleCommand: (raw) => {
                const cRaw = raw.trim();           // Keep original case
                const c = cRaw.toUpperCase();      // For checking LIST, RUN, etc.
                
                if(!c) return IO.prompt();

                // Check for Line Number (Program Entry)
                // Use cRaw here to preserve the casing of the code being entered
                const m = cRaw.match(/^(\d+)\s*(.*)/);
                
                if(m) {
                    const l = parseInt(m[1]);
                    SYS.program = SYS.program.filter(x=>x.line!==l);
                    // m[2] contains the source code with original case
                    if(m[2]) SYS.program.push({line:l, src:m[2]});
                    IO.prompt();
                } else {
                    // Immediate Mode Commands
                    if(c==='LIST') { 
                        SYS.program.sort((a,b)=>a.line-b.line); 
                        SYS.program.forEach(l=>IO.print(`${l.line} ${l.src}`)); 
                        IO.prompt(); 
                    }
                    else if(c==='RUN') ENGINE.run();
                    else if(c==='NEW') { 
                        SYS.program=[]; SYS.vars={}; SCREEN.clear(); IO.prompt(); 
                    }
                    else {
                        // Direct Execution (Immediate Mode)
                        // Pass cRaw so commands like PRINT "Hello" preserve case
                        try { 
                            Compiler.compile({line:0, src:cRaw})(SYS,IO,GRAPHICS,FS)?.then?(()=>IO.prompt()):IO.prompt(); 
                        }
                        catch(e){ 
                            IO.print("?SYNTAX ERROR"); 
                            IO.prompt(); 
                        }
                    }
                }
            },
            prompt: () => { IO.cursorVisible=true; IO.print("]", false); }
        };

        // --- ENGINE ---
        const ENGINE = {
            run: async () => {
                SYS.program.sort((a,b)=>a.line-b.line); SYS.compiled=[]; SYS.labels={};
                SYS.program.forEach((x,i)=>{ SYS.labels[x.line]=i; SYS.compiled.push(Compiler.compile(x)); });
                SYS.pc=0; SYS.running=true; SYS.break=false; SYS.vars={}; SYS.arrays={}; SYS.stack=[]; SYS.forStack={};
                breakBtn.style.display='block'; IO.cursorVisible=false; SCREEN.removeCursor();
                const t0=performance.now(); let ly=t0; let ops=0;
                while(SYS.running && SYS.pc < SYS.compiled.length) {
                    const res = SYS.compiled[SYS.pc](SYS,IO,GRAPHICS,FS);
                    if(res && res.then) { await res; ly=performance.now(); }
                    SYS.pc++; ops++;
                    if((ops%100)===0 && SYS.break) { IO.print(`\nBREAK IN ${SYS.program[SYS.pc-1]?.line}`); SYS.running=false; break; }
                    if((ops&4095)===0 && (performance.now()-ly)>14) { await new Promise(r=>setTimeout(r,0)); ly=performance.now(); }
                }
                breakBtn.style.display='none';
                SYS.running=false; IO.prompt();
            }
        };

        // --- EVENTS ---
        document.addEventListener('click', (e)=>{ if(e.target.id !== 'help-search') inputTrap.focus(); });
        breakBtn.onclick = (e) => { e.preventDefault(); if(SYS.running) SYS.break=true; inputTrap.focus(); };
        
        // --- Global Key Listener ---
        window.onkeydown = (e) => { 
            // 1. Handle Break
            if(e.key==='Escape' && SYS.running) { SYS.break=true; return; }

            // 2. Feed INKEY$ Buffer
            if(SYS.running) {
                // Pass key to IO buffer
                IO.bufferKey(e.key);
            }
        };

        window.onkeydown = (e) => { 
            // 1. Handle Break (ESC)
            if(e.key === 'Escape' && SYS.running) { 
                SYS.break = true; 
                return; 
            }

            // 2. Handle Runtime Keys (INKEY$)
            if(SYS.running) {
                if (!SYS.inputCallback) {
                    IO.bufferKey(e.key);
                    e.preventDefault();
                }
            } 
            // 3. NEW: Handle Command Submission (At Prompt)
            else if (e.key === 'Enter') {
                e.preventDefault();
                const cmd = inputTrap.value; // Get command from hidden input
                inputTrap.value = "";        // Clear input for next time
                SCREEN.newline();            // Move cursor to next line
                IO.handleCommand(cmd);       // Execute command
            }
        };

        inputTrap.oninput = (e) => { if(e.inputType==="insertText" && e.data) SCREEN.put(e.data); };

        // --- Paste Support ---
        inputTrap.addEventListener('paste', (e) => {
            e.preventDefault();
            // Get pasted data via clipboard API
            const text = (e.clipboardData || window.clipboardData).getData('text');
            
            // Split into lines, filtering out empty ones
            const lines = text.split(/\r?\n/).filter(line => line.trim() !== "");

            // Process each line sequentially
            const processLine = async (index) => {
                if (index >= lines.length) return;
                
                const line = lines[index];
                
                // Echo the line to the screen
                IO.print(line);
                
                // If it looks like a line number + code, handle it as a command
                // If it is a direct command (RUN, LIST), handle it immediately
                if (SYS.inputCallback) {
                    // If we are stuck at an INPUT prompt, feed it the data
                    const cb = SYS.inputCallback; 
                    SYS.inputCallback = null; 
                    cb(line);
                } else {
                    // Standard command processing
                    IO.handleCommand(line);
                }

                // Small delay to prevent freezing UI on large pastes
                setTimeout(() => processLine(index + 1), 10);
            };

            processLine(0);
        });


        // Init
        document.fonts.load(CONFIG.font).then(() => {
            SCREEN.init();
            IO.print("APPLESOFTY BASIC TRANSPILER v18.5");
            IO.print("(this work is licensed under CC BY 4.0)")
            IO.print("");
            IO.print("TYPE 'HELP' FOR MANUAL");
            IO.prompt();
        });

    </script>
</body>
</html>
