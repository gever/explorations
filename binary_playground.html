<!DOCTYPE html>
<html>
<head>
<title>Particle Gravity Simulation with Orbital Init</title>
<style>
  body { margin: 0; overflow: hidden; background-color: #000; }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="particleCanvas"></canvas>
<script>
  // This code (particle_sim_orbital.js) was generated by Gemini,
  // a large language model from Google, on 2025-07-01
  //
  // This code was created based on user prompts from Gever Tulley.

  const canvas = document.getElementById('particleCanvas');
  const ctx = canvas.getContext('2d');

  let width = canvas.width = window.innerWidth;
  let height = canvas.height = window.innerHeight;

  window.addEventListener('resize', () => {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
  });

  const G = 1.0;
  const numParticles = 200;
  const particles = [];

  let isMouseDown = false;
  let startPos = { x: 0, y: 0 };
  let currentPos = { x: 0, y: 0 };
  const newParticleMass = 100;
  const velocityScale = 0.05;

  let translation = { x: 0, y: 0 };

  class Particle {
    constructor(x, y, mass, vel = {x: 0, y: 0}) {
      this.pos = { x, y };
      this.vel = vel;
      this.mass = mass;
      this.updateRadius();
    }

    updateRadius() {
      this.radius = Math.sqrt(this.mass) / 2.0;
      if (this.radius < 0.5) this.radius = 0.5;
    }

    applyForce(force) {
      this.vel.x += force.x / this.mass;
      this.vel.y += force.y / this.mass;
    }

    update() {
      this.pos.x += this.vel.x;
      this.pos.y += this.vel.y;
    }

    draw() {
      ctx.beginPath();
      ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
      ctx.fillStyle = `hsl(${Math.min(this.mass * 2, 360)}, 100%, 50%)`;
      ctx.fill();
    }
  }

  function init() {
    const centerX = width / 2;
    const centerY = height / 2;
    const orbitalSpeed = 0.8; // Tweak this for different orbital effects

    for (let i = 0; i < numParticles; i++) {
      const mass = Math.random() * 20 + 5;
      const x = Math.random() * (width * 0.75) + (width / 8);
      const y = Math.random() * (height * 0.7) + (height / 8);
      
      const dx = x - centerX;
      const dy = y - centerY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist === 0) {
        particles.push(new Particle(x, y, mass)); // Zero velocity if at center
        continue;
      }

      const vel = {
        x: -dy / dist * orbitalSpeed,
        y: dx / dist * orbitalSpeed
      };

      particles.push(new Particle(x, y, mass, vel));
    }
  }

  canvas.addEventListener('mousedown', (e) => {
    isMouseDown = true;
    startPos.x = e.clientX - translation.x;
    startPos.y = e.clientY - translation.y;
    currentPos.x = startPos.x;
    currentPos.y = startPos.y;
  });

  canvas.addEventListener('mousemove', (e) => {
    if (isMouseDown) {
      currentPos.x = e.clientX - translation.x;
      currentPos.y = e.clientY - translation.y;
    }
  });

  canvas.addEventListener('mouseup', (e) => {
    if (isMouseDown) {
      isMouseDown = false;
      const vel = {
        x: (e.clientX - translation.x - startPos.x) * velocityScale,
        y: (e.clientY - translation.y - startPos.y) * velocityScale
      };
      particles.push(new Particle(startPos.x, startPos.y, newParticleMass, vel));
    }
  });

  function animate() {
    requestAnimationFrame(animate);

    let totalMass = 0;
    let com = { x: 0, y: 0 };
    if (particles.length > 0) {
      for (const p of particles) {
        com.x += p.pos.x * p.mass;
        com.y += p.pos.y * p.mass;
        totalMass += p.mass;
      }
      com.x /= totalMass;
      com.y /= totalMass;
    } else {
        com.x = width / 2;
        com.y = height / 2;
    }

    translation.x = width / 2 - com.x;
    translation.y = height / 2 - com.y;

    ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
    ctx.fillRect(0, 0, width, height);
    
    ctx.save();
    ctx.translate(translation.x, translation.y);

    for (let i = 0; i < particles.length; i++) {
      for (let j = i + 1; j < particles.length; j++) {
        const p1 = particles[i];
        const p2 = particles[j];
        const dx = p2.pos.x - p1.pos.x;
        const dy = p2.pos.y - p1.pos.y;
        const distSq = dx * dx + dy * dy;
        
        if (distSq == 0) continue;
        const dist = Math.sqrt(distSq);

        if (dist < p1.radius + p2.radius) {
          const combinedMass = p1.mass + p2.mass;
          p1.vel.x = (p1.vel.x * p1.mass + p2.vel.x * p2.mass) / combinedMass;
          p1.vel.y = (p1.vel.y * p1.mass + p2.vel.y * p2.mass) / combinedMass;
          p1.pos.x = (p1.pos.x * p1.mass + p2.pos.x * p2.mass) / combinedMass;
          p1.pos.y = (p1.pos.y * p1.mass + p2.pos.y * p2.mass) / combinedMass;
          p1.mass = combinedMass;
          p1.updateRadius();
          particles.splice(j, 1);
          j--;
        } else {
          const force = (G * p1.mass * p2.mass) / distSq;
          const forceX = (force * dx) / dist;
          const forceY = (force * dy) / dist;
          p1.applyForce({ x: forceX, y: forceY });
          p2.applyForce({ x: -forceX, y: -forceY });
        }
      }
    }

    particles.forEach(p => {
      p.update();
      p.draw();
    });

    if (isMouseDown) {
      ctx.beginPath();
      ctx.moveTo(startPos.x, startPos.y);
      ctx.lineTo(currentPos.x, currentPos.y);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      const tempRadius = Math.sqrt(newParticleMass) / 2.0;
      ctx.beginPath();
      ctx.arc(startPos.x, startPos.y, tempRadius, 0, Math.PI * 2);
      ctx.fillStyle = `hsl(${Math.min(newParticleMass * 2, 360)}, 100%, 50%)`;
      ctx.fill();
    }
    
    ctx.restore();

    ctx.fillStyle = '#000';
    ctx.fillRect(width - 180, 10, 170, 30);
    ctx.fillStyle = 'darkgray';
    ctx.font = '16px monospace';
    ctx.textAlign = 'right';
    ctx.fillText(`particles: ${particles.length}`, width - 20, 30);
  }

  init();
  animate();
</script>
</body>
</html>
