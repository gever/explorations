<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pareidolia Evolution v5</title>
    <style>
        /* --- DEFAULT STATE (Cells White, Margins Black) --- */
        body {
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            
            /* Margin Color (Default: Dark) */
            background-color: #111; 
            /* Text Color (Default: Light) */
            color: #ccc;
            transition: background-color 0.3s, color 0.3s;
        }

        /* --- TOGGLED STATE (Cells Black, Margins White) --- */
        body.inverted {
            background-color: #e0e0e0;
            color: #111;
        }

        #layout-container {
            flex-grow: 1;
            width: 100%;
            height: 100%;
            padding: 20px;
            box-sizing: border-box;
        }

        #grid-target {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 15px;
            width: 100%;
            height: 100%;
        }

        .cell {
            position: relative;
            overflow: hidden;
            transition: background-color 0.3s, border-color 0.2s;
            cursor: pointer;
            background: #ffffff;
            border: 1px solid #333;
        }

        body.inverted .cell {
            background: #000000;
            border: 1px solid #ccc;
        }

        .cell:hover {
            border-color: #ff0055 !important;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #instructions {
            text-align: center;
            padding: 15px;
            border-top: 1px solid;
            border-color: inherit;
            font-size: 0.9em;
            flex-shrink: 0;
            user-select: none;
            background: rgba(0,0,0,0.1);
        }

        /* --- ANIMATIONS --- */
        .highlight {
            animation: flash 0.3s ease-out;
        }

        .shake-reset {
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes flash {
            0% { border-color: #ff0055; box-shadow: 0 0 20px #ff0055; }
            100% { border-color: inherit; box-shadow: none; }
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
    </style>
</head>
<body>

    <div id="layout-container">
        <div id="grid-target"></div>
    </div>

    <div id="instructions">
        Gen <span id="gen-count">0</span>: Click to Evolve. <strong>[SPACE]</strong> Toggle Theme. <strong>[R]</strong> Randomize.
    </div>

<script>
    /**
     * CONFIGURATION
     */
    const GRID_SIZE = 3; 
    
    // UPDATED: Range for initial random complexity
    const MIN_INITIAL_CIRCLES = 15;
    const MAX_INITIAL_CIRCLES = 60;
    
    const MUTATION_RATE = 0.05; 
    const MUTATION_CHANCE = 0.5; 
    const ADD_CHANCE = 0.2; 
    const DEL_CHANCE = 0.2; 
    
    /**
     * DATA STRUCTURES
     */
    class Genome {
        constructor() {
            this.genes = [];
        }

        // UPDATED: Randomizes count between MIN and MAX
        randomize() {
            this.genes = [];
            // Calculate random integer between min and max (inclusive)
            const count = Math.floor(Math.random() * (MAX_INITIAL_CIRCLES - MIN_INITIAL_CIRCLES + 1)) + MIN_INITIAL_CIRCLES;
            
            for (let i = 0; i < count; i++) {
                this.genes.push(this.randomGene());
            }
        }

        randomGene() {
            return {
                x: Math.random(),
                y: Math.random(),
                rad: Math.random(),     
                a: Math.random(),       
                r: Math.random(),       
                g: Math.random(),       
                b: Math.random()        
            };
        }

        clone() {
            const copy = new Genome();
            copy.genes = this.genes.map(g => ({...g}));
            return copy;
        }

        mutate() {
            this.genes.forEach(g => {
                if (Math.random() < MUTATION_CHANCE) {
                    g.x = this.clamp(g.x + this.drift());
                    g.y = this.clamp(g.y + this.drift());
                    g.rad = this.clamp(g.rad + this.drift());
                    g.a = this.clamp(g.a + (this.drift() * 0.5)); 
                    g.r = this.clamp(g.r + this.drift());
                    g.g = this.clamp(g.g + this.drift());
                    g.b = this.clamp(g.b + this.drift());
                }
            });
            if (Math.random() < ADD_CHANCE) this.genes.push(this.randomGene());
            if (Math.random() < DEL_CHANCE && this.genes.length > 1) {
                this.genes.splice(Math.floor(Math.random() * this.genes.length), 1);
            }
        }

        drift() { return (Math.random() * 2 - 1) * MUTATION_RATE; }
        clamp(val) { return Math.max(0, Math.min(1, val)); }
    }

    /**
     * STATE
     */
    const gridTarget = document.getElementById('grid-target');
    const genDisplay = document.getElementById('gen-count');
    let generation = 0;
    const population = [];
    const canvases = [];

    /**
     * INITIALIZATION
     */
    function init() {
        const totalCells = GRID_SIZE * GRID_SIZE;

        for (let i = 0; i < totalCells; i++) {
            const cellDiv = document.createElement('div');
            cellDiv.className = 'cell';
            
            const cvs = document.createElement('canvas');
            cvs.id = `c-${i}`; 
            
            const interact = (e) => { 
                e.preventDefault(); 
                cellDiv.classList.remove('highlight');
                void cellDiv.offsetWidth; 
                cellDiv.classList.add('highlight');
                evolve(i); 
            };
            
            cvs.addEventListener('mousedown', interact);
            cvs.addEventListener('touchstart', interact);
            
            cellDiv.appendChild(cvs);
            gridTarget.appendChild(cellDiv);
            canvases.push(cvs);

            const genome = new Genome();
            genome.randomize(); // Uses new MIN/MAX logic
            population.push(genome);
        }

        const ro = new ResizeObserver(entries => {
            requestAnimationFrame(resize);
        });
        ro.observe(document.getElementById('layout-container'));

        // KEYBOARD CONTROLS
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                document.body.classList.toggle('inverted');
            }
            if (e.key.toLowerCase() === 'r') {
                resetPopulation();
            }
        });
    }

    /**
     * EVOLUTION LOGIC
     */
    function evolve(selectedIndex) {
        const parent = population[selectedIndex];
        
        for (let i = 0; i < population.length; i++) {
            if (i === selectedIndex) continue; 
            const child = parent.clone();
            child.mutate();
            population[i] = child;
        }
        generation++;
        genDisplay.innerText = generation;
        drawAll();
    }

    function resetPopulation() {
        // Reset Genes with new random counts
        population.forEach(p => p.randomize());
        
        generation = 0;
        genDisplay.innerText = generation;
        
        gridTarget.classList.remove('shake-reset');
        void gridTarget.offsetWidth; 
        gridTarget.classList.add('shake-reset');

        drawAll();
    }

    /**
     * DRAWING
     */
    function drawAll() {
        canvases.forEach((cvs, i) => drawGenome(cvs, population[i]));
    }

    function drawGenome(canvas, genome) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const halfW = w / 2;

        ctx.clearRect(0, 0, w, h);

        const drawCircles = () => {
            ctx.globalCompositeOperation = 'source-over'; 

            genome.genes.forEach(g => {
                const radius = Math.max(1, g.rad * (w / 3)); 
                const cx = g.x * w; 
                const cy = g.y * h;
                
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                
                const r = Math.floor(g.r * 255);
                const gr = Math.floor(g.g * 255);
                const b = Math.floor(g.b * 255);
                
                ctx.fillStyle = `rgba(${r}, ${gr}, ${b}, ${g.a})`;
                ctx.fill();
            });
        };

        ctx.save();
        ctx.beginPath();
        ctx.rect(0, 0, halfW, h); 
        ctx.clip();
        drawCircles();
        ctx.restore();

        ctx.save();
        ctx.beginPath();
        ctx.rect(halfW, 0, halfW, h); 
        ctx.clip();
        ctx.translate(w, 0);
        ctx.scale(-1, 1);
        drawCircles();
        ctx.restore();
    }

    function resize() {
        canvases.forEach(cvs => {
            const rect = cvs.parentElement.getBoundingClientRect();
            if (cvs.width !== rect.width || cvs.height !== rect.height) {
                cvs.width = rect.width;
                cvs.height = rect.height;
            }
        });
        drawAll();
    }

    init();

</script>
</body>
</html>
