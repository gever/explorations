<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pareidolia Evolution</title>
    <style>
        body {
            margin: 0;
            background-color: #111; /* Darker background to make white pop */
            height: 100vh;
            display: flex;
            flex-direction: column;
            font-family: monospace;
            color: #ccc;
        }
        
        #grid {
            flex-grow: 1;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 10px; /* Increased spacing between cells */
            padding: 10px;
            box-sizing: border-box; /* Ensures padding doesn't overflow viewport */
        }

        canvas {
            width: 100%;
            height: 100%;
            background-color: #000;
            cursor: pointer;
            border: 2px solid white; /* The requested white border */
            box-sizing: border-box;
            transition: border-color 0.1s;
        }

        canvas:hover {
            border-color: #ff0055; /* Visual feedback on hover */
        }

        #instructions {
            text-align: center;
            padding: 15px;
            background: #222;
            border-top: 1px solid #444;
        }
    </style>
</head>
<body>

<div id="grid">
    </div>
<div id="instructions">Click a cell to select it as the parent. The others will mutate.</div>

<script>
    const GRID_SIZE = 3; 
    const INITIAL_CIRCLES = 40;
    const MUTATION_RATE = 0.05; 
    const MUTATION_CHANCE = 0.5; 
    const ADD_CHANCE = 0.2; 
    const DEL_CHANCE = 0.2; 
    
    class Genome {
        constructor() {
            this.genes = [];
        }

        randomize(count) {
            this.genes = [];
            for (let i = 0; i < count; i++) this.genes.push(this.randomGene());
        }

        randomGene() {
            return {
                x: Math.random(),
                y: Math.random(),
                rad: Math.random(),     
                a: Math.random(),       
                r: Math.random(),       
                g: Math.random(),       
                b: Math.random()        
            };
        }

        clone() {
            const copy = new Genome();
            copy.genes = this.genes.map(g => ({...g}));
            return copy;
        }

        mutate() {
            this.genes.forEach(g => {
                if (Math.random() < MUTATION_CHANCE) {
                    g.x = this.clamp(g.x + this.drift());
                    g.y = this.clamp(g.y + this.drift());
                    g.rad = this.clamp(g.rad + this.drift());
                    g.a = this.clamp(g.a + this.drift());
                    g.r = this.clamp(g.r + this.drift());
                    g.g = this.clamp(g.g + this.drift());
                    g.b = this.clamp(g.b + this.drift());
                }
            });
            if (Math.random() < ADD_CHANCE) this.genes.push(this.randomGene());
            if (Math.random() < DEL_CHANCE && this.genes.length > 1) {
                this.genes.splice(Math.floor(Math.random() * this.genes.length), 1);
            }
        }

        drift() { return (Math.random() * 2 - 1) * MUTATION_RATE; }
        clamp(val) { return Math.max(0, Math.min(1, val)); }
    }

    const container = document.getElementById('grid');
    const population = [];
    const canvases = [];

    function init() {
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            const cvs = document.createElement('canvas');
            cvs.id = `cell-${i}`;
            
            // Interaction listeners
            const interact = (e) => { e.preventDefault(); evolve(i); };
            cvs.addEventListener('mousedown', interact);
            cvs.addEventListener('touchstart', interact);
            
            container.appendChild(cvs);
            canvases.push(cvs);

            const genome = new Genome();
            genome.randomize(INITIAL_CIRCLES);
            population.push(genome);
        }

        // Use ResizeObserver for robust sizing
        const ro = new ResizeObserver(() => {
            resize();
        });
        ro.observe(container);
    }

    function evolve(selectedIndex) {
        const parent = population[selectedIndex];
        for (let i = 0; i < population.length; i++) {
            if (i === selectedIndex) continue; 
            const child = parent.clone();
            child.mutate();
            population[i] = child;
        }
        drawAll();
    }

    function drawAll() {
        canvases.forEach((cvs, i) => drawGenome(cvs, population[i]));
    }

    function drawGenome(canvas, genome) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const halfW = w / 2;

        ctx.clearRect(0, 0, w, h);

        // Helper to draw the circles
        const drawCircles = () => {
            genome.genes.forEach(g => {
                const radius = g.rad * (w / 4); 
                const cx = g.x * w; 
                const cy = g.y * h;
                
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                const r = Math.floor(g.r * 255);
                const gr = Math.floor(g.g * 255);
                const b = Math.floor(g.b * 255);
                ctx.fillStyle = `rgba(${r}, ${gr}, ${b}, ${g.a})`;
                ctx.fill();
            });
        };

        // 1. LEFT SIDE
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, 0, halfW, h); // Clip to left half
        ctx.clip();
        drawCircles();
        ctx.restore();

        // 2. RIGHT SIDE (Mirrored)
        ctx.save();
        ctx.beginPath();
        ctx.rect(halfW, 0, halfW, h); // Clip to right half
        ctx.clip();
        
        // Transform to mirror: Move origin to right edge, flip scale
        ctx.translate(w, 0);
        ctx.scale(-1, 1);
        
        drawCircles();
        ctx.restore();
    }

    function resize() {
        canvases.forEach(cvs => {
            // Get the physical pixel size of the container
            const rect = cvs.getBoundingClientRect();
            // Update internal canvas resolution
            cvs.width = rect.width;
            cvs.height = rect.height;
        });
        drawAll();
    }

    init();

</script>
</body>
</html>
