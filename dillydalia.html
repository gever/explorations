<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pareidolia Evolution</title>
    <style>
        body {
            margin: 0;
            background-color: #111;
            height: 100vh;
            display: flex;
            flex-direction: column;
            font-family: monospace;
            color: #ccc;
            overflow: hidden; /* Prevent scrollbars */
            height: 100%;
        }
        
        #layout-container {
            flex-grow: 1;
            width: 200px;
            height: 300px;
            padding: 10px;
            box-sizing: border-box;
        }

        table {
            width: 100%;
            height: 100%;
            border-collapse: separate; 
            border-spacing: 10px; /* The margin between cells */
            table-layout: fixed; /* Ensures equal cell sizes */
        }

        td {
            padding: 0;
            vertical-align: top;
            width: 200px;
            height: 200px;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #000;
            cursor: pointer;
            border: 2px solid white; /* The white border */
            box-sizing: border-box; 
        }

        canvas:hover {
            border-color: #ff0055;
        }

        #instructions {
            text-align: center;
            padding: 10px;
            background: #222;
            border-top: 1px solid #444;
            flex-shrink: 0;
        }
    </style>
</head>
<body>

<div>
    <table id="grid-table">
        <tbody id="grid-body">
            </tbody>
    </table>
</div>

<div id="instructions">Click a cell to select it as the parent. The others will mutate.</div>

<script>
    /**
     * CONFIGURATION
     */
    const GRID_SIZE = 3; 
    const INITIAL_CIRCLES = 40;
    const MUTATION_RATE = 0.05; 
    const MUTATION_CHANCE = 0.5; 
    const ADD_CHANCE = 0.2; 
    const DEL_CHANCE = 0.2; 
    
    /**
     * DATA STRUCTURES
     */
    class Genome {
        constructor() {
            this.genes = [];
        }

        randomize(count) {
            this.genes = [];
            for (let i = 0; i < count; i++) this.genes.push(this.randomGene());
        }

        randomGene() {
            return {
                x: Math.random(),
                y: Math.random(),
                rad: Math.random(),     
                a: Math.random(),       
                r: Math.random(),       
                g: Math.random(),       
                b: Math.random()        
            };
        }

        clone() {
            const copy = new Genome();
            copy.genes = this.genes.map(g => ({...g}));
            return copy;
        }

        mutate() {
            this.genes.forEach(g => {
                if (Math.random() < MUTATION_CHANCE) {
                    g.x = this.clamp(g.x + this.drift());
                    g.y = this.clamp(g.y + this.drift());
                    g.rad = this.clamp(g.rad + this.drift());
                    g.a = this.clamp(g.a + this.drift());
                    g.r = this.clamp(g.r + this.drift());
                    g.g = this.clamp(g.g + this.drift());
                    g.b = this.clamp(g.b + this.drift());
                }
            });
            if (Math.random() < ADD_CHANCE) this.genes.push(this.randomGene());
            if (Math.random() < DEL_CHANCE && this.genes.length > 1) {
                this.genes.splice(Math.floor(Math.random() * this.genes.length), 1);
            }
        }

        drift() { return (Math.random() * 2 - 1) * MUTATION_RATE; }
        clamp(val) { return Math.max(0, Math.min(1, val)); }
    }

    /**
     * STATE
     */
    const tableBody = document.getElementById('grid-body');
    const population = [];
    const canvases = [];

    /**
     * INITIALIZATION
     */
    function init() {
        let globalIndex = 0;

        for (let r = 0; r < GRID_SIZE; r++) {
            const tr = document.createElement('tr');
            
            for (let c = 0; c < GRID_SIZE; c++) {
                const td = document.createElement('td');
                const cvs = document.createElement('canvas');
                
                // Capture index for closure
                const idx = globalIndex;
                cvs.id = `cell-${idx}`;
                
                // Interaction
                const interact = (e) => { e.preventDefault(); evolve(idx); };
                cvs.addEventListener('mousedown', interact);
                cvs.addEventListener('touchstart', interact);
                
                td.appendChild(cvs);
                tr.appendChild(td);
                canvases.push(cvs);

                // Create DNA
                const genome = new Genome();
                genome.randomize(INITIAL_CIRCLES);
                population.push(genome);

                globalIndex++;
            }
            tableBody.appendChild(tr);
        }

        // Handle Resizing
        const ro = new ResizeObserver(() => {
            resize();
        });
        ro.observe(document.getElementById('layout-container'));
    }

    /**
     * EVOLUTION LOGIC
     */
    function evolve(selectedIndex) {
        const parent = population[selectedIndex];
        
        for (let i = 0; i < population.length; i++) {
            if (i === selectedIndex) continue; // Elitism: keep parent
            
            const child = parent.clone();
            child.mutate();
            population[i] = child;
        }
        drawAll();
    }

    /**
     * DRAWING
     */
    function drawAll() {
        canvases.forEach((cvs, i) => drawGenome(cvs, population[i]));
    }

    function drawGenome(canvas, genome) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const halfW = w / 2;

        ctx.clearRect(0, 0, w, h);

        const drawCircles = () => {
            genome.genes.forEach(g => {
                const radius = g.rad * (w / 4); 
                const cx = g.x * w; 
                const cy = g.y * h;
                
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                const r = Math.floor(g.r * 255);
                const gr = Math.floor(g.g * 255);
                const b = Math.floor(g.b * 255);
                ctx.fillStyle = `rgba(${r}, ${gr}, ${b}, ${g.a})`;
                ctx.fill();
            });
        };

        // 1. LEFT SIDE
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, 0, halfW, h); 
        ctx.clip();
        drawCircles();
        ctx.restore();

        // 2. RIGHT SIDE (Mirrored)
        ctx.save();
        ctx.beginPath();
        ctx.rect(halfW, 0, halfW, h); 
        ctx.clip();
        
        ctx.translate(w, 0);
        ctx.scale(-1, 1);
        
        drawCircles();
        ctx.restore();
    }

    function resize() {
        canvases.forEach(cvs => {
            // Match internal resolution to display size
            const rect = cvs.getBoundingClientRect();
            // Check for valid dimensions to avoid errors if hidden
            if (rect.width > 0 && rect.height > 0) {
                cvs.width = rect.width;
                cvs.height = rect.height;
            }
        });
        drawAll();
    }

    // Start
    init();

</script>
</body>
</html>
