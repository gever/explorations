<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pareidolia Evolution v2</title>
    <style>
        body {
            margin: 0;
            background-color: #111;
            height: 100vh;
            display: flex;
            flex-direction: column;
            font-family: 'Courier New', monospace;
            color: #888;
            overflow: hidden;
        }

        /* The main container for the grid */
        #layout-container {
            flex-grow: 1;
            width: 100%;
            height: 100%;
            padding: 20px;
            box-sizing: border-box;
        }

        /* CSS Grid replaces the Table for better responsiveness */
        #grid-target {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 15px;
            width: 100%;
            height: 100%;
        }

        .cell {
            position: relative;
            border: 1px solid #333;
            overflow: hidden;
            background: #000;
            transition: border-color 0.2s;
        }

        .cell:hover {
            border-color: #ff0055;
            cursor: pointer;
        }

        /* The canvas fills the grid cell */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #instructions {
            text-align: center;
            padding: 15px;
            background: #1a1a1a;
            border-top: 1px solid #333;
            font-size: 0.9em;
            flex-shrink: 0;
            user-select: none;
        }

        .highlight {
            animation: flash 0.3s ease-out;
        }

        @keyframes flash {
            0% { border-color: #fff; box-shadow: 0 0 20px #fff; }
            100% { border-color: #333; box-shadow: none; }
        }
    </style>
</head>
<body>

    <div id="layout-container">
        <div id="grid-target"></div>
    </div>

    <div id="instructions">
        Generation <span id="gen-count">0</span>: Click a face to select it as parent.
    </div>

<script>
    /**
     * CONFIGURATION
     */
    const GRID_SIZE = 3; 
    const INITIAL_CIRCLES = 50; // Increased slightly for more detail
    const MUTATION_RATE = 0.05; 
    const MUTATION_CHANCE = 0.5; 
    const ADD_CHANCE = 0.2; 
    const DEL_CHANCE = 0.2; 
    
    /**
     * DATA STRUCTURES
     */
    class Genome {
        constructor() {
            this.genes = [];
        }

        randomize(count) {
            this.genes = [];
            for (let i = 0; i < count; i++) this.genes.push(this.randomGene());
        }

        randomGene() {
            return {
                x: Math.random(),
                y: Math.random(),
                rad: Math.random(),     
                a: Math.random(),       
                r: Math.random(),       
                g: Math.random(),       
                b: Math.random()        
            };
        }

        clone() {
            const copy = new Genome();
            // Deep copy the gene objects
            copy.genes = this.genes.map(g => ({...g}));
            return copy;
        }

        mutate() {
            this.genes.forEach(g => {
                if (Math.random() < MUTATION_CHANCE) {
                    g.x = this.clamp(g.x + this.drift());
                    g.y = this.clamp(g.y + this.drift());
                    g.rad = this.clamp(g.rad + this.drift());
                    // Alpha mutation is smaller to prevent ghosts
                    g.a = this.clamp(g.a + (this.drift() * 0.5)); 
                    g.r = this.clamp(g.r + this.drift());
                    g.g = this.clamp(g.g + this.drift());
                    g.b = this.clamp(g.b + this.drift());
                }
            });

            // Add new gene
            if (Math.random() < ADD_CHANCE) this.genes.push(this.randomGene());
            
            // Remove gene (keep at least 1)
            if (Math.random() < DEL_CHANCE && this.genes.length > 1) {
                this.genes.splice(Math.floor(Math.random() * this.genes.length), 1);
            }
        }

        drift() { return (Math.random() * 2 - 1) * MUTATION_RATE; }
        clamp(val) { return Math.max(0, Math.min(1, val)); }
    }

    /**
     * STATE
     */
    const gridTarget = document.getElementById('grid-target');
    const genDisplay = document.getElementById('gen-count');
    let generation = 0;
    const population = [];
    const canvases = [];

    /**
     * INITIALIZATION
     */
    function init() {
        const totalCells = GRID_SIZE * GRID_SIZE;

        for (let i = 0; i < totalCells; i++) {
            // DOM Creation
            const cellDiv = document.createElement('div');
            cellDiv.className = 'cell';
            
            const cvs = document.createElement('canvas');
            // ID for debugging
            cvs.id = `c-${i}`; 
            
            // Interaction
            const interact = (e) => { 
                e.preventDefault(); 
                // Visual feedback
                cellDiv.classList.remove('highlight');
                void cellDiv.offsetWidth; // Trigger reflow
                cellDiv.classList.add('highlight');
                evolve(i); 
            };
            
            cvs.addEventListener('mousedown', interact);
            cvs.addEventListener('touchstart', interact);
            
            cellDiv.appendChild(cvs);
            gridTarget.appendChild(cellDiv);
            canvases.push(cvs);

            // Genetics
            const genome = new Genome();
            genome.randomize(INITIAL_CIRCLES);
            population.push(genome);
        }

        // Observer for responsive resizing
        const ro = new ResizeObserver(entries => {
            // Debounce slightly or just run
            requestAnimationFrame(resize);
        });
        ro.observe(document.getElementById('layout-container'));
    }

    /**
     * EVOLUTION LOGIC
     */
    function evolve(selectedIndex) {
        const parent = population[selectedIndex];
        
        for (let i = 0; i < population.length; i++) {
            if (i === selectedIndex) continue; // Keep the parent exactly as is
            
            const child = parent.clone();
            child.mutate();
            population[i] = child;
        }
        generation++;
        genDisplay.innerText = generation;
        drawAll();
    }

    /**
     * DRAWING
     */
    function drawAll() {
        canvases.forEach((cvs, i) => drawGenome(cvs, population[i]));
    }

    function drawGenome(canvas, genome) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const halfW = w / 2;

        ctx.clearRect(0, 0, w, h);

        const drawCircles = () => {
            // Global Composite Operation "lighter" creates nice glowing effects
            // when circles overlap, similar to additive light
            ctx.globalCompositeOperation = 'source-over'; 

            genome.genes.forEach(g => {
                // Radius relative to width
                const radius = Math.max(1, g.rad * (w / 3)); 
                const cx = g.x * w; 
                const cy = g.y * h;
                
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                
                const r = Math.floor(g.r * 255);
                const gr = Math.floor(g.g * 255);
                const b = Math.floor(g.b * 255);
                
                ctx.fillStyle = `rgba(${r}, ${gr}, ${b}, ${g.a})`;
                ctx.fill();
            });
        };

        // 1. LEFT SIDE
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, 0, halfW, h); 
        ctx.clip();
        drawCircles();
        ctx.restore();

        // 2. RIGHT SIDE (Mirrored)
        ctx.save();
        ctx.beginPath();
        ctx.rect(halfW, 0, halfW, h); 
        ctx.clip();
        
        ctx.translate(w, 0);
        ctx.scale(-1, 1);
        
        drawCircles();
        ctx.restore();
    }

    function resize() {
        canvases.forEach(cvs => {
            // Get the container size provided by CSS Grid
            const rect = cvs.parentElement.getBoundingClientRect();
            
            // Only update if dimensions actually changed (prevents flicker)
            if (cvs.width !== rect.width || cvs.height !== rect.height) {
                cvs.width = rect.width;
                cvs.height = rect.height;
            }
        });
        drawAll();
    }

    // Start
    init();

</script>
</body>
</html>
